# TripCanvas 경로 최적화/거리·시간 계산 메모

## 1) “최적화를 통한 장소 선정” 기준

### 결론

* **현재 Main.mjs의 최적화는 ‘장소 선정’이 아니라, 이미 선택된 places의 ‘방문 순서 최적화’만 함.**
* “어떤 장소 5개를 고르냐(선정)”는 **서버 `/plan/generate`(Gemini) 쪽 로직**에서 결정됨.
* Main.mjs는 서버가 준 `dp.places`를 받아서 **순서만 바꾸고 UI(리스트/마커) 표시를 그 순서로 맞춤.**

### (A) 순서 최적화 기준(클라이언트)

**파일:** `client/public/pages/Main.mjs`
**관련 함수(검색 키워드):**

* `optimizePlacesNearest(originLL, places)`
* `twoOptImprove(originLL, items, maxPasses = 6)`
* `tourLength(originLL, orderedLLs)`
* `dist(a, b)`

**기준 요약**

1. 기준점(origin) = **숙소 좌표 `accLL`**
2. 거리 척도 = `dist()`

   * `dx = lng 차이`, `dy = lat 차이`
   * `sqrt(dx^2 + dy^2)` (유클리드 거리)
   * ⚠️ 도로거리/시간이 아니라 **위경도 평면 근사**(정확한 km 아님, “가까운 순서” heuristic)
3. 초기 해 = **Nearest Neighbor (NN)**

   * 현재 위치에서 가장 가까운 다음 장소를 반복 선택
4. 개선 = **2-opt (최대 6 pass)**

   * 구간을 뒤집어서 전체 순회 길이(`tourLength`)가 줄어들면 채택
5. 좌표 없는 place는 `withoutLL`로 빠져서 **맨 뒤에 그대로 붙음**

**실제 적용 위치(흐름)**

* `renderDayTabs(route)` 내부 `setActive(day)`에서
  `buildDayRouteCache(dp, day, effectiveAcc)` 호출
  → 여기서 `optimizePlacesNearest()`로 `orderedPlaces`를 만들어 캐시에 저장
  → 이후 UI는 `dpForUI = { ...dp, places: cached.orderedPlaces }`로 렌더링

> 즉, “최적화 기준”은 **숙소 기준으로 전체 순회(숙소→…→숙소) 길이를 줄이는 방향의 순서 재배치**고, “장소 선정”은 아님.

---

## 2) 거리 계산 기준(도로 거리)

### 결론

* 거리/시간은 **카카오모빌리티 Directions 결과**를 기준으로 함.
* 서버 `/route/directions`가 카카오에 요청하고,

  * `distanceM`(미터)
  * `durationS`(초)
  * `points`(polyline용 lat/lng 배열)
    를 내려줌.

### (A) 서버 기준(카카오 Directions)

**파일:** `server/router/route.mjs`
**엔드포인트:** `POST /route/directions`

**핵심 로직**

* 요청: `origin`, `destination`, optional `waypoints`, `priority`
* 응답 파싱:

  * polyline 점들: `sections[].roads[].vertexes`를 `{lat, lng}`로 변환해 `points` 생성
  * 거리: `route0.summary.distance` 또는 `sections[].distance` 합
  * 시간: `route0.summary.duration` 또는 `sections[].duration` 합
* 반환: `{ points, distanceM, durationS }`

**따라서 “거리 계산 기준”은**

* 카카오모빌리티가 계산한 **도로기반 거리(distance)** (미터)
* “TIME” 우선순위일 때는 **시간 최적 경로 기준의 거리**가 들어옴(우회가 생길 수도 있음)

---

## 3) 시간 계산 기준(예상 소요시간)

### 결론

* 시간도 카카오모빌리티의 `duration`(초)을 그대로 씀.
* 표시 형식은 `fmtMin(sec)` / `fmtDuration(sec)`로 변환.

**파일:** `client/public/pages/Main.mjs`
**관련 함수**

* `fetchDirections(originLL, destLL)` → `{distanceM, durationS, points}`
* `fmtMin(sec)` (분/시간 단위)
* `fmtDuration(sec)` (총합 표시용)

---

## 4) “어디에서 실행(호출)되냐” 실행 흐름 메모

### (1) Day 탭 선택/초기 진입 시

**파일:** `Main.mjs`

* `loadLatestRouteAndRenderTabs()`
  → `GET /route/latest`
  → `renderDayTabs(data.route)`
* `renderDayTabs(route)` 안의 `setActive(day)`가 핵심 오케스트레이터

`setActive(day)`에서 실행되는 것들:

1. `effectiveAcc = getEffectiveAccommodation(plans, day)`

   * 오늘 숙소 없으면 이전 숙소 fallback
2. `buildDayRouteCache(dp, day, effectiveAcc)`

   * ✅ 여기서 최적화 실행(`optimizePlacesNearest` + `twoOptImprove`)
3. `renderPlacesList(dpForUI)`
4. `renderMarkersForDay(dpForUI, day, effectiveAcc)`
5. `await computeDaySegments(day)`

   * ✅ 여기서 “구간별 거리/시간” 계산 (카카오 Directions 여러 번 호출)
6. `renderPlacesList(dpForUI)` 다시 호출

   * ✅ 계산된 구간 정보를 리스트에 반영하기 위해 재렌더
7. (너가 설정한 기본값) `window.__tc_onAccInfo?.()`

   * ✅ 숙소→1 표시/센터/바운드/텍스트 등

---

### (2) “구간별 거리/시간” 계산(리스트의 place-move용)

**파일:** `Main.mjs`
**함수:** `computeDaySegments(day)`

* 시작점 `prev = accLL`
* i=0..n-1 반복:

  * `r = await fetchDirections(prev, curLL)`
  * `segments[i] = (prev → places[i])`  ✅ “들어오는 구간”
  * `prev = curLL`
* 마지막:

  * `back = await fetchDirections(prev, accLL)` ✅ 마지막→숙소
* 캐시:

  * `daySegmentsCache.set(day, { segments, back })`

> 참고: 너는 현재 리스트 표시를 “idx 카드 = segments[idx+1]”로 바꿨지?
> 그래서 리스트는 “현재→다음”처럼 보이지만, 캐시는 원래 “직전→현재” 기반으로 저장되어 있음.

---

### (3) 숙소 → 1 경로(기본값/버튼/숙소 클릭)

**파일:** `Main.mjs`

* `window.__tc_onAccInfo = () => { ... drawAccToFirstPlaceRoute(...) ... }`
* `drawAccToFirstPlaceRoute(dayPlan, effectiveAccommodation)`

  * 내부에서 `fetchDirections(accLL, firstLL)` 호출
  * polyline 그리고 `fitMapToTwo(...)`로 bounds
  * (네가 추가한) `ensureSegmentStatsEl()`로 “숙소→1” 거리/시간 표시

---

### (4) 리스트 클릭 시 “현재→다음 / 마지막→숙소” 표시

**파일:** `Main.mjs`

* 카드 클릭 → `window.__tc_onPlaceInfo(idx)`

  * 여기서 info overlay 띄우고
  * 너가 바꾼 함수(예: `showNextLegFromPlaceIdx(idx)`류)로 polyline + 거리시간 표시

---

## 5) 기준 요약 (한 줄)

* **순서 최적화(클라이언트):** 숙소 기준, 위경도 유클리드 거리로 NN+2opt → “빠른 근사 순서”
* **거리/시간(도로 기준):** 카카오모빌리티 Directions `distance/duration`(TIME 우선)
* **선정(어떤 장소 뽑는지):** `/plan/generate`에서 LLM이 결정(현재 메모엔 코드가 안 보이므로 정확 기준은 그 파일을 봐야 확정)

---

원하면, 네 프로젝트 폴더에서 아래 2개 파일도 붙여주면(또는 해당 부분만) **“줄 번호까지”** 정확히 찍어서 메모를 다시 만들어줄게:

1. `server/router/plan.mjs` (또는 `/plan/generate` 구현 파일)
2. `server/services/TripPlan_base_api.py` (Gemini 호출/프롬프트/장소 선정 기준 들어있는 곳)
